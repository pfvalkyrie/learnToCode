<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Brick Breaker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0d0d1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #e0e0ff;
      overflow: hidden;
    }

    h1 {
      font-size: clamp(1rem, 5vw, 2rem);
      letter-spacing: 4px;
      margin-bottom: 8px;
      color: #a0aaff;
      text-transform: uppercase;
    }

    #hud {
      display: flex;
      gap: clamp(12px, 4vw, 40px);
      margin-bottom: 8px;
      font-size: clamp(0.7rem, 2.5vw, 1rem);
      letter-spacing: 2px;
    }

    #hud span { color: #7080ff; }
    #hud b    { color: #e0e0ff; }

    canvas {
      display: block;
      background: #0a0a18;
      border: 2px solid #3040a0;
      border-radius: 4px;
      box-shadow: 0 0 30px rgba(80, 100, 255, 0.3);
      /* Scale canvas to fit viewport while keeping aspect ratio */
      width: min(480px, 96vw);
      height: auto;
      touch-action: none;
    }

    #message {
      margin-top: 10px;
      font-size: clamp(0.75rem, 2.5vw, 1.1rem);
      letter-spacing: 2px;
      min-height: 1.5em;
      color: #ffdd88;
      text-align: center;
      padding: 0 8px;
    }

    #controls {
      margin-top: 8px;
      font-size: clamp(0.55rem, 1.8vw, 0.75rem);
      color: #505080;
      letter-spacing: 1px;
      text-align: center;
    }

    #mobileControls {
      display: flex;
      gap: 24px;
      margin-top: 14px;
    }

    #mobileControls button {
      background: #1e2870;
      color: #a0b0ff;
      border: 2px solid #3040a0;
      border-radius: 10px;
      font-size: 1.6rem;
      padding: 14px 32px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      transition: background 0.1s;
    }

    #mobileControls button:active {
      background: #3858cc;
    }

    #btnLaunch {
      background: #2a5cd6;
      color: #ffffff;
      border-color: #6080ff;
      font-size: 1rem;
      letter-spacing: 2px;
      padding: 14px 20px;
      min-width: 90px;
    }

    #btnLaunch:active {
      background: #4a7aff;
    }
  </style>
</head>
<body>
  <h1>Brick Breaker</h1>

  <div id="hud">
    <div><span>SCORE </span><b id="scoreDisplay">0</b></div>
    <div><span>LEVEL </span><b id="levelDisplay">1</b></div>
    <div><span>LIVES </span><b id="livesDisplay">3</b></div>
  </div>

  <canvas id="canvas" width="480" height="700"></canvas>

  <div id="message">Tap or press SPACE to launch</div>
  <div id="controls">Mouse / drag / buttons to move &nbsp;|&nbsp; Tap / SPACE to launch</div>

  <div id="mobileControls">
    <button id="btnLeft">&#9664;</button>
    <button id="btnLaunch">LAUNCH</button>
    <button id="btnRight">&#9654;</button>
  </div>

  <script>
    const canvas  = document.getElementById('canvas');
    const ctx     = canvas.getContext('2d');
    const W = canvas.width;   // logical width  = 480
    const H = canvas.height;  // logical height = 560

    // ── Layout constants ───────────────────────────────────────────
    const PADDLE_W  = 80;
    const PADDLE_H  = 12;
    const PADDLE_Y  = H - 40;
    const PADDLE_SPD = 6;
    const BALL_R          = 7;
    const BIG_BALL_R      = 14;
    const TINY_BALL_R     = 3;
    const BIG_BALL_FRAMES = 180;   // 3 s at 60 fps
    const TINY_BALL_FRAMES = 600;  // 10 s at 60 fps
    const BASE_SPD        = 6;
    const SPD_MAX         = 11;
    const SPD_BOOST       = 1.02;
    const WIDE_FRAMES     = 600;   // 10 s
    const NARROW_FRAMES   = 480;   // 8 s

    // ── Power-up config ────────────────────────────────────────────
    // Types: positive=green/blue, negative=red, rare=cyan
    const PU_TYPES   = ['sticky', 'ghost', 'bigball', 'tiny', 'wide', 'narrow', 'force'];
    const PU_HUE     = { sticky: 48, ghost: 185, bigball: 285, tiny: 22, wide: 120, narrow: 0, force: 190 };
    const PU_LABEL   = { sticky: 'S', ghost: 'G', bigball: 'B', tiny: 'T', wide: 'W', narrow: 'N', force: 'F' };
    // Weights: force is rare (~10 % of drops), narrow matches others (player can dodge)
    const PU_WEIGHTS = [3, 3, 3, 3, 3, 3, 2];   // total = 20
    const PU_W = 18, PU_H = 22, PU_SPD = 1.6;
    const PU_DROP_CHANCE = 0.3;

    const BRICK_COLS = 10;
    const BRICK_ROWS = 6;
    const BRICK_W   = 38;
    const BRICK_H   = 18;
    const BRICK_PAD =  8;
    const BRICK_OX  = (W - (BRICK_COLS * (BRICK_W + BRICK_PAD) - BRICK_PAD)) / 2;
    const BRICK_OY  = 60;

    // ── 4 colours by hit count (1=sky blue, 2=mint, 3=amber, 4=pink) ─
    const BRICK_HUES = [200, 145, 38, 335];   // indexed by maxHp - 1
    function getBrickHue(maxHp)          { return BRICK_HUES[Math.min(maxHp - 1, 3)]; }
    function getBrickColor(maxHp, alpha = 1) {
      return `hsla(${getBrickHue(maxHp)}, 85%, 62%, ${alpha})`;
    }

    // ── State ──────────────────────────────────────────────────────
    let state     = 'idle';
    let score     = 0;
    let lives     = 3;
    let level     = 1;
    let paddle    = { x: W / 2 - PADDLE_W / 2, y: PADDLE_Y, w: PADDLE_W };
    let keys      = {};
    let pointerX  = null;   // mouse or touch X in canvas logical coords
    let ball, bricks, particles;
    let fallingPowerups = [];
    let fx = { sticky: false, ghost: false, bigball: 0, tiny: 0, wide: 0, narrow: 0, force: false };
    let shakeFrames = 0, shakeAmt = 0;

    // ── Ball / brick helpers ───────────────────────────────────────
    function freshBall() {
      return { x: W / 2, y: PADDLE_Y - BALL_R - 1, vx: 0, vy: 0, launched: false, r: BALL_R };
    }

    function buildBricks(lvl) {
      const maxHP = Math.min(lvl, 4);
      const list  = [];
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          const hp = Math.max(1, Math.min(maxHP, Math.floor(r / 2) + 1));
          list.push({
            x: BRICK_OX + c * (BRICK_W + BRICK_PAD),
            y: BRICK_OY + r * (BRICK_H + BRICK_PAD),
            w: BRICK_W, h: BRICK_H,
            hp, maxHp: hp,
            col: c, row: r,
            alive: true,
          });
        }
      }
      return list;
    }

    function startGame() {
      score = 0; lives = 3; level = 1;
      paddle.x      = W / 2 - PADDLE_W / 2;
      paddle.w      = PADDLE_W;
      bricks        = buildBricks(1);
      particles     = [];
      fallingPowerups = [];
      fx            = { sticky: false, ghost: false, bigball: 0, tiny: 0, wide: 0, narrow: 0, force: false };
      shakeFrames   = 0;
      ball          = freshBall();
      ball.x        = paddle.x + paddle.w / 2;
      state         = 'playing';
      updateHUD();
      showMsg('Tap or press SPACE to launch');
    }

    function launchBall() {
      if (ball.launched) return;
      const spd   = BASE_SPD + (level - 1) * 0.5;
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 3);
      ball.vx = Math.cos(angle) * spd;
      ball.vy = Math.sin(angle) * spd;
      ball.launched = true;
      fx.sticky = false;   // one catch per pickup
    }

    // Scale ball speed without changing direction
    function nudgeSpeed(factor) {
      const cur = Math.hypot(ball.vx, ball.vy);
      if (cur === 0) return;
      const nxt = Math.min(cur * factor, SPD_MAX);
      ball.vx = (ball.vx / cur) * nxt;
      ball.vy = (ball.vy / cur) * nxt;
    }
    function resetSpeed() {
      const baseSpd = BASE_SPD + (level - 1) * 0.5;
      const cur = Math.hypot(ball.vx, ball.vy);
      if (cur === 0) return;
      ball.vx = (ball.vx / cur) * baseSpd;
      ball.vy = (ball.vy / cur) * baseSpd;
    }

    // ── Particle system ────────────────────────────────────────────
    // Bounce: two expanding rings + spark trails
    function spawnBounce(x, y, hue) {
      const h = hue ?? 220;
      particles.push({ type: 'ring', x, y, r: ball.r + 1, hue: h, alpha: 1.0, rspd: 3.5 });
      particles.push({ type: 'ring', x, y, r: ball.r * 0.4, hue: h, alpha: 0.6, rspd: 1.5 });
      for (let i = 0; i < 5; i++) {
        const a   = Math.random() * Math.PI * 2;
        const spd = 2.5 + Math.random() * 3.5;
        particles.push({
          type: 'spark', x, y,
          vx: Math.cos(a) * spd, vy: Math.sin(a) * spd,
          hue: h, alpha: 1, decay: 0.09 + Math.random() * 0.04,
        });
      }
    }

    // Brick break: coloured shards fly out and fall
    function spawnBreak(brick) {
      const hue = getBrickHue(brick.maxHp);
      for (let i = 0; i < 16; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd   = 1.5 + Math.random() * 4;
        particles.push({
          type: 'shard',
          x:  brick.x + brick.w / 2 + (Math.random() - 0.5) * brick.w * 0.5,
          y:  brick.y + brick.h / 2 + (Math.random() - 0.5) * brick.h * 0.5,
          vx: Math.cos(angle) * spd,
          vy: Math.sin(angle) * spd - 1,   // slight upward bias
          w:  3 + Math.random() * 5,
          h:  2 + Math.random() * 4,
          rot:  Math.random() * Math.PI * 2,
          rotV: (Math.random() - 0.5) * 0.25,
          hue,
          alpha: 1,
          decay: 0.028 + Math.random() * 0.025,
          gravity: 0.15,
        });
      }
    }

    function spawnPowerup(brick) {
      if (Math.random() > PU_DROP_CHANCE) return;
      // Weighted random pick
      const total = PU_WEIGHTS.reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      let idx = 0;
      for (; idx < PU_WEIGHTS.length - 1; idx++) { r -= PU_WEIGHTS[idx]; if (r <= 0) break; }
      fallingPowerups.push({
        type: PU_TYPES[idx],
        x: brick.x + brick.w / 2 - PU_W / 2,
        y: brick.y + brick.h / 2,
      });
    }

    function activatePowerup(type) {
      if (type === 'sticky') {
        fx.sticky = true;
      } else if (type === 'ghost') {
        fx.ghost = true;
      } else if (type === 'bigball') {
        fx.bigball = BIG_BALL_FRAMES; fx.tiny = 0;
        ball.r = BIG_BALL_R;
      } else if (type === 'tiny') {
        fx.tiny = TINY_BALL_FRAMES; fx.bigball = 0;
        ball.r = TINY_BALL_R;
      } else if (type === 'wide') {
        fx.wide = WIDE_FRAMES; fx.narrow = 0;
        paddle.w = Math.round(PADDLE_W * 1.6);
      } else if (type === 'narrow') {
        fx.narrow = NARROW_FRAMES; fx.wide = 0;
        paddle.w = Math.round(PADDLE_W * 0.55);
      } else if (type === 'force') {
        fx.force = true;
      }
      spawnBounce(paddle.x + paddle.w / 2, paddle.y, PU_HUE[type]);
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (p.type === 'ring') {
          p.r    += p.rspd ?? 2;
          p.alpha -= 0.07;
        } else if (p.type === 'spark') {
          p.x  += p.vx; p.y  += p.vy;
          p.vx *= 0.82; p.vy *= 0.82;
          p.alpha -= p.decay;
        } else {
          p.x   += p.vx;
          p.y   += p.vy;
          p.vy  += p.gravity;
          p.rot += p.rotV;
          p.alpha -= p.decay;
        }
        if (p.alpha <= 0) particles.splice(i, 1);
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const a = Math.max(0, p.alpha);
        ctx.save();
        ctx.globalAlpha = a;
        if (p.type === 'ring') {
          ctx.strokeStyle = `hsl(${p.hue}, 90%, 70%)`;
          ctx.lineWidth   = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.stroke();
        } else if (p.type === 'spark') {
          ctx.strokeStyle = `hsl(${p.hue}, 100%, 75%)`;
          ctx.lineWidth   = 1.5;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - p.vx * 3, p.y - p.vy * 3);
          ctx.stroke();
        } else {
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = `hsl(${p.hue}, 90%, 65%)`;
          ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
        }
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }

    // ── Collision helpers ──────────────────────────────────────────
    function circleRect(cx, cy, cr, rx, ry, rw, rh) {
      const nx = Math.max(rx, Math.min(cx, rx + rw));
      const ny = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - nx, dy = cy - ny;
      return dx * dx + dy * dy < cr * cr;
    }

    function resolveRect(rx, ry, rw, rh, b) {
      const overL = (b.x + b.r) - rx;
      const overR = (rx + rw) - (b.x - b.r);
      const overT = (b.y + b.r) - ry;
      const overB = (ry + rh) - (b.y - b.r);
      if (Math.min(overL, overR) < Math.min(overT, overB)) {
        b.vx = -b.vx;
        b.x  = overL < overR ? rx - b.r : rx + rw + b.r;
      } else {
        b.vy = -b.vy;
        b.y  = overT < overB ? ry - b.r : ry + rh + b.r;
      }
    }

    // ── Update ─────────────────────────────────────────────────────
    function update() {
      if (state !== 'playing') return;

      // Move paddle
      if (pointerX !== null) paddle.x = pointerX - paddle.w / 2;
      if (keys['ArrowLeft'])  paddle.x -= PADDLE_SPD;
      if (keys['ArrowRight']) paddle.x += PADDLE_SPD;
      paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

      if (!ball.launched) {
        // Glue ball to paddle centre
        ball.x = paddle.x + paddle.w / 2;
      } else {
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall bounces (only top wall ends ghost mode)
        if (ball.x - ball.r < 0) {
          ball.x = ball.r; ball.vx = Math.abs(ball.vx);
          nudgeSpeed(SPD_BOOST);
          spawnBounce(ball.x, ball.y, 220);
        }
        if (ball.x + ball.r > W) {
          ball.x = W - ball.r; ball.vx = -Math.abs(ball.vx);
          nudgeSpeed(SPD_BOOST);
          spawnBounce(ball.x, ball.y, 220);
        }
        if (ball.y - ball.r < 0) {
          ball.y = ball.r; ball.vy = Math.abs(ball.vy);
          nudgeSpeed(SPD_BOOST); fx.ghost = false;
          spawnBounce(ball.x, ball.y, 220);
          shakeFrames = 4; shakeAmt = 3;
        }

        // Ball fell off bottom
        if (ball.y - ball.r > H) {
          if (fx.force) {
            // Force-field saves it — one-time bounce
            ball.y = H - ball.r;
            ball.vy = -Math.abs(ball.vy);
            fx.force = false;
            spawnBounce(ball.x, H - ball.r, PU_HUE.force);
            shakeFrames = 6; shakeAmt = 4;
          } else {
            lives--;
            updateHUD();
            fallingPowerups = [];
            fx = { sticky: false, ghost: false, bigball: 0, tiny: 0, wide: 0, narrow: 0, force: false };
            paddle.w = PADDLE_W;
            shakeFrames = 0;
            if (lives <= 0) {
              state = 'dead';
              showMsg('GAME OVER — press LAUNCH to restart');
              updateLaunchBtn();
              return;
            }
            ball   = freshBall();
            ball.x = paddle.x + paddle.w / 2;
            showMsg('Press LAUNCH to continue');
            updateLaunchBtn();
            return;
          }
        }

        // Paddle collision
        if (
          ball.vy > 0 &&
          circleRect(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, PADDLE_H)
        ) {
          if (fx.sticky) {
            ball.vx = 0; ball.vy = 0;
            ball.launched = false;
            ball.y = paddle.y - ball.r;
            spawnBounce(ball.x, ball.y, PU_HUE.sticky);
            showMsg('STICKY — press LAUNCH to release');
            updateLaunchBtn();
          } else {
            const hit     = (ball.x - paddle.x) / paddle.w;
            const angle   = -Math.PI / 2 + (hit - 0.5) * Math.PI * 0.7;
            const baseSpd = BASE_SPD + (level - 1) * 0.5;
            ball.vx = Math.cos(angle) * baseSpd;
            ball.vy = Math.sin(angle) * baseSpd;
            ball.y  = paddle.y - ball.r;
            spawnBounce(ball.x, ball.y, 200);
          }
        }

        // Brick collisions — ghost passes through without damaging
        let alive = 0;
        for (const b of bricks) {
          if (!b.alive) continue;
          alive++;
          if (!fx.ghost && circleRect(ball.x, ball.y, ball.r, b.x, b.y, b.w, b.h)) {
            resolveRect(b.x, b.y, b.w, b.h, ball);
            nudgeSpeed(SPD_BOOST);
            spawnBounce(ball.x, ball.y, getBrickHue(b.maxHp));
            b.hp--;
            if (b.hp <= 0) {
              b.alive = false;
              alive--;
              spawnBreak(b);
              spawnPowerup(b);
              shakeFrames = 5; shakeAmt = 2 + b.maxHp;
              score += 10 * b.maxHp * level;
              updateHUD();
            }
          }
        }

        // All bricks cleared → next level
        if (alive === 0) {
          level++;
          updateHUD();
          bricks = buildBricks(level);
          ball   = freshBall();
          ball.x = paddle.x + paddle.w / 2;
          showMsg(`Level ${level} — press LAUNCH`);
          updateLaunchBtn();
        }
      } // end ball.launched

      // ── Always runs (even before launch, so power-ups never freeze) ──
      for (let i = fallingPowerups.length - 1; i >= 0; i--) {
        const pu = fallingPowerups[i];
        pu.y += PU_SPD;
        if (
          pu.y + PU_H >= paddle.y &&
          pu.x + PU_W >= paddle.x &&
          pu.x        <= paddle.x + paddle.w
        ) {
          activatePowerup(pu.type);
          fallingPowerups.splice(i, 1);
          continue;
        }
        if (pu.y > H) fallingPowerups.splice(i, 1);
      }

      // Timers
      if (fx.bigball > 0) { fx.bigball--; if (fx.bigball === 0) ball.r = BALL_R; }
      if (fx.tiny   > 0) { fx.tiny--;   if (fx.tiny   === 0) ball.r = BALL_R; }
      if (fx.wide   > 0) { fx.wide--;   if (fx.wide   === 0) paddle.w = PADDLE_W; }
      if (fx.narrow > 0) { fx.narrow--; if (fx.narrow === 0) paddle.w = PADDLE_W; }

      // Shake decay
      if (shakeFrames > 0) shakeFrames--;

      updateParticles();
    }

    // ── Draw ───────────────────────────────────────────────────────
    function draw() {
      ctx.clearRect(0, 0, W, H);
      ctx.save();
      if (shakeFrames > 0) {
        ctx.translate(
          (Math.random() - 0.5) * shakeAmt,
          (Math.random() - 0.5) * shakeAmt
        );
      }

      // Bricks
      for (const b of bricks) {
        if (!b.alive) continue;
        const ratio = b.hp / b.maxHp;
        const alpha = 0.45 + 0.55 * ratio;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle   = getBrickColor(b.maxHp);
        ctx.beginPath();
        ctx.roundRect(b.x, b.y, b.w, b.h, 3);
        ctx.fill();

        // Top-edge shine
        ctx.globalAlpha = alpha * 0.35;
        ctx.fillStyle   = '#ffffff';
        ctx.fillRect(b.x + 2, b.y + 2, b.w - 4, 3);

        // Damage cracks
        if (b.maxHp > 1 && b.hp < b.maxHp) {
          ctx.globalAlpha = 0.6;
          ctx.strokeStyle = 'rgba(0,0,0,0.7)';
          ctx.lineWidth   = 1.5;
          ctx.beginPath();
          ctx.moveTo(b.x + b.w * 0.35, b.y + 3);
          ctx.lineTo(b.x + b.w * 0.50, b.y + b.h - 3);
          ctx.stroke();
          if (b.hp <= b.maxHp - 2) {
            ctx.beginPath();
            ctx.moveTo(b.x + b.w * 0.62, b.y + 3);
            ctx.lineTo(b.x + b.w * 0.47, b.y + b.h - 3);
            ctx.stroke();
          }
        }
        ctx.restore();
      }

      // Particles (behind paddle/ball)
      drawParticles();

      // Falling power-ups
      for (const pu of fallingPowerups) {
        const hue = PU_HUE[pu.type];
        ctx.save();
        ctx.fillStyle   = `hsl(${hue}, 90%, 50%)`;
        ctx.strokeStyle = `hsl(${hue}, 90%, 80%)`;
        ctx.lineWidth   = 1.5;
        ctx.beginPath();
        ctx.roundRect(pu.x, pu.y, PU_W, PU_H, PU_W / 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle    = '#fff';
        ctx.font         = 'bold 11px Courier New';
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(PU_LABEL[pu.type], pu.x + PU_W / 2, pu.y + PU_H / 2);
        ctx.restore();
      }

      // Force-field barrier (drawn at bottom before paddle)
      if (fx.force) {
        const fy = H - 6;
        const fg = ctx.createLinearGradient(0, fy, W, fy);
        fg.addColorStop(0,   'transparent');
        fg.addColorStop(0.15, `hsl(${PU_HUE.force}, 100%, 70%)`);
        fg.addColorStop(0.5,  '#ffffff');
        fg.addColorStop(0.85, `hsl(${PU_HUE.force}, 100%, 70%)`);
        fg.addColorStop(1,   'transparent');
        ctx.save();
        ctx.shadowColor = `hsl(${PU_HUE.force}, 100%, 60%)`;
        ctx.shadowBlur  = 14;
        ctx.strokeStyle = fg;
        ctx.lineWidth   = 3;
        ctx.beginPath(); ctx.moveTo(0, fy); ctx.lineTo(W, fy); ctx.stroke();
        ctx.restore();
      }

      // Paddle (tinted by active effect)
      const pg = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + PADDLE_H);
      if (fx.sticky) {
        pg.addColorStop(0, '#ffe060'); pg.addColorStop(1, '#cc8800');
        ctx.strokeStyle = '#ffe090';
      } else if (fx.wide > 0) {
        pg.addColorStop(0, '#60ff90'); pg.addColorStop(1, '#00aa44');
        ctx.strokeStyle = '#88ffaa';
      } else if (fx.narrow > 0) {
        pg.addColorStop(0, '#ff6060'); pg.addColorStop(1, '#cc2200');
        ctx.strokeStyle = '#ff8888';
      } else {
        pg.addColorStop(0, '#7090ff'); pg.addColorStop(1, '#3050cc');
        ctx.strokeStyle = '#aabbff';
      }
      ctx.fillStyle = pg;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(paddle.x, paddle.y, paddle.w, PADDLE_H, 6);
      ctx.fill();
      ctx.stroke();

      // Ball (tinted by active effect)
      ctx.save();
      if (fx.ghost) ctx.globalAlpha = 0.45;
      const ballInner = fx.ghost   ? '#aaffff'
                      : fx.bigball > 0 ? '#ff88ff'
                      : fx.tiny   > 0 ? '#ffcc88'
                      : '#ffffff';
      const ballOuter = fx.ghost   ? '#44bbcc'
                      : fx.bigball > 0 ? '#cc44cc'
                      : fx.tiny   > 0 ? '#cc4400'
                      : '#88aaff';
      const bg = ctx.createRadialGradient(
        ball.x - 2, ball.y - 2, 1,
        ball.x,     ball.y,     ball.r
      );
      bg.addColorStop(0, ballInner);
      bg.addColorStop(1, ballOuter);
      ctx.fillStyle = bg;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();   // ball save/restore

      ctx.restore();   // shake save/restore
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── HUD helpers ────────────────────────────────────────────────
    function updateHUD() {
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('levelDisplay').textContent = level;
      document.getElementById('livesDisplay').textContent = lives;
    }

    function showMsg(msg) { document.getElementById('message').textContent = msg; }
    function clearMsg()   { document.getElementById('message').textContent = ''; }

    function updateLaunchBtn() {
      const btn = document.getElementById('btnLaunch');
      if (state === 'dead')    { btn.textContent = 'RESTART'; return; }
      if (!ball || !ball.launched) { btn.textContent = 'LAUNCH';  return; }
      btn.textContent = '·····';
    }

    // ── Input ──────────────────────────────────────────────────────
    function handleAction() {
      if (state === 'playing' && !ball.launched) {
        launchBall();
        clearMsg();
      } else if (state === 'idle' || state === 'dead') {
        startGame();
        launchBall();
        clearMsg();
      }
      updateLaunchBtn();
    }

    // Keyboard
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') { e.preventDefault(); handleAction(); }
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // Mouse
    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      pointerX = (e.clientX - r.left) * (W / r.width);
    });
    canvas.addEventListener('mouseleave', () => { pointerX = null; });
    canvas.addEventListener('click', handleAction);

    // Touch – convert from CSS pixels to logical canvas pixels
    function touchX(e) {
      const r = canvas.getBoundingClientRect();
      return (e.touches[0].clientX - r.left) * (W / r.width);
    }

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      pointerX = touchX(e);
      handleAction();
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      pointerX = touchX(e);
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
      e.preventDefault();
    }, { passive: false });

    // Mobile left/right buttons
    const btnLeft  = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    function holdLeft(down)  { keys['ArrowLeft']  = down; }
    function holdRight(down) { keys['ArrowRight'] = down; }

    btnLeft.addEventListener('pointerdown',  e => { e.preventDefault(); holdLeft(true);  handleAction(); });
    btnLeft.addEventListener('pointerup',    e => { e.preventDefault(); holdLeft(false); });
    btnLeft.addEventListener('pointerleave', e => { holdLeft(false); });

    btnRight.addEventListener('pointerdown',  e => { e.preventDefault(); holdRight(true);  handleAction(); });
    btnRight.addEventListener('pointerup',    e => { e.preventDefault(); holdRight(false); });
    btnRight.addEventListener('pointerleave', e => { holdRight(false); });

    const btnLaunch = document.getElementById('btnLaunch');
    btnLaunch.addEventListener('pointerdown', e => { e.preventDefault(); handleAction(); });

    // ── Boot ───────────────────────────────────────────────────────
    startGame();
    updateLaunchBtn();
    loop();
  </script>
</body>
</html>
