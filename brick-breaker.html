<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Brick Breaker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0d0d1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #e0e0ff;
    }

    h1 {
      font-size: 2rem;
      letter-spacing: 4px;
      margin-bottom: 12px;
      color: #a0aaff;
      text-transform: uppercase;
    }

    #hud {
      display: flex;
      gap: 40px;
      margin-bottom: 12px;
      font-size: 1rem;
      letter-spacing: 2px;
    }

    #hud span { color: #7080ff; }
    #hud b { color: #e0e0ff; }

    canvas {
      display: block;
      background: #0a0a18;
      border: 2px solid #3040a0;
      border-radius: 4px;
      box-shadow: 0 0 30px rgba(80, 100, 255, 0.3);
    }

    #message {
      margin-top: 16px;
      font-size: 1.1rem;
      letter-spacing: 2px;
      min-height: 1.5em;
      color: #ffdd88;
    }

    #controls {
      margin-top: 12px;
      font-size: 0.75rem;
      color: #505080;
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <h1>Brick Breaker</h1>

  <div id="hud">
    <div><span>SCORE </span><b id="scoreDisplay">0</b></div>
    <div><span>LEVEL </span><b id="levelDisplay">1</b></div>
    <div><span>LIVES </span><b id="livesDisplay">3</b></div>
  </div>

  <canvas id="canvas" width="480" height="560"></canvas>

  <div id="message">Press SPACE or click to start</div>
  <div id="controls">← → Arrow keys or mouse to move &nbsp;|&nbsp; SPACE to launch ball</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const W = canvas.width;
    const H = canvas.height;

    // ── Tuning constants ─────────────────────────────────────────
    const PADDLE_W = 80;
    const PADDLE_H = 12;
    const PADDLE_Y = H - 40;
    const PADDLE_SPEED = 6;

    const BALL_R = 7;
    const BASE_BALL_SPEED = 5;

    const BRICK_COLS = 10;
    const BRICK_ROWS = 6;
    const BRICK_W = 42;
    const BRICK_H = 18;
    const BRICK_PAD = 4;
    const BRICK_OFFSET_X = (W - (BRICK_COLS * (BRICK_W + BRICK_PAD) - BRICK_PAD)) / 2;
    const BRICK_OFFSET_Y = 60;

    // Brick colors per row (health determines shade)
    const ROW_COLORS = [
      '#ff4466', // red
      '#ff7733', // orange
      '#ffdd00', // yellow
      '#44cc44', // green
      '#33aaff', // blue
      '#aa55ff', // purple
    ];

    // ── State ─────────────────────────────────────────────────────
    let state = 'idle'; // idle | playing | paused | dead | won
    let score = 0;
    let lives = 3;
    let level = 1;

    let paddle = { x: W / 2 - PADDLE_W / 2, y: PADDLE_Y };
    let keys = {};
    let mouseX = null;

    let ball = resetBall();
    let bricks = buildBricks(level);

    function resetBall() {
      return {
        x: W / 2,
        y: PADDLE_Y - BALL_R - 1,
        vx: 0,
        vy: 0,
        launched: false,
      };
    }

    function buildBricks(lvl) {
      const bricks = [];
      // Higher levels have tougher bricks (more hits needed in later rows)
      const maxHealth = Math.min(lvl, 3);
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          const health = Math.max(1, Math.min(maxHealth, Math.floor(r / 2) + 1));
          bricks.push({
            x: BRICK_OFFSET_X + c * (BRICK_W + BRICK_PAD),
            y: BRICK_OFFSET_Y + r * (BRICK_H + BRICK_PAD),
            w: BRICK_W,
            h: BRICK_H,
            health,
            maxHealth: health,
            color: ROW_COLORS[r % ROW_COLORS.length],
            alive: true,
          });
        }
      }
      return bricks;
    }

    // ── Launch ball ───────────────────────────────────────────────
    function launchBall() {
      if (ball.launched) return;
      const speed = BASE_BALL_SPEED + (level - 1) * 0.5;
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 3;
      ball.vx = Math.cos(angle) * speed;
      ball.vy = Math.sin(angle) * speed;
      ball.launched = true;
    }

    // ── Collision helpers ─────────────────────────────────────────
    function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
      const nearX = Math.max(rx, Math.min(cx, rx + rw));
      const nearY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - nearX;
      const dy = cy - nearY;
      return dx * dx + dy * dy < cr * cr;
    }

    function resolveCircleRect(rx, ry, rw, rh, ball) {
      // Determine which face was hit
      const overlapL = (ball.x + BALL_R) - rx;
      const overlapR = (rx + rw) - (ball.x - BALL_R);
      const overlapT = (ball.y + BALL_R) - ry;
      const overlapB = (ry + rh) - (ball.y - BALL_R);

      const minH = Math.min(overlapL, overlapR);
      const minV = Math.min(overlapT, overlapB);

      if (minH < minV) {
        ball.vx = -ball.vx;
        if (overlapL < overlapR) ball.x = rx - BALL_R;
        else ball.x = rx + rw + BALL_R;
      } else {
        ball.vy = -ball.vy;
        if (overlapT < overlapB) ball.y = ry - BALL_R;
        else ball.y = ry + rh + BALL_R;
      }
    }

    // ── Update ────────────────────────────────────────────────────
    function update() {
      if (state !== 'playing') return;

      // Paddle movement
      if (mouseX !== null) {
        paddle.x = mouseX - PADDLE_W / 2;
      }
      if (keys['ArrowLeft']) paddle.x -= PADDLE_SPEED;
      if (keys['ArrowRight']) paddle.x += PADDLE_SPEED;
      paddle.x = Math.max(0, Math.min(W - PADDLE_W, paddle.x));

      // Keep ball on paddle if not launched
      if (!ball.launched) {
        ball.x = paddle.x + PADDLE_W / 2;
        return;
      }

      // Move ball
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Wall collisions
      if (ball.x - BALL_R < 0) { ball.x = BALL_R; ball.vx = Math.abs(ball.vx); }
      if (ball.x + BALL_R > W) { ball.x = W - BALL_R; ball.vx = -Math.abs(ball.vx); }
      if (ball.y - BALL_R < 0) { ball.y = BALL_R; ball.vy = Math.abs(ball.vy); }

      // Fell off bottom
      if (ball.y - BALL_R > H) {
        lives--;
        updateHUD();
        if (lives <= 0) {
          state = 'dead';
          showMessage('GAME OVER — Press SPACE to restart');
          return;
        }
        ball = resetBall();
        ball.x = paddle.x + PADDLE_W / 2;
        showMessage('Press SPACE to launch');
        return;
      }

      // Paddle collision
      if (
        ball.vy > 0 &&
        rectCircleCollide(paddle.x, paddle.y, PADDLE_W, PADDLE_H, ball.x, ball.y, BALL_R)
      ) {
        // Angle depends on where ball hits paddle
        const hitPos = (ball.x - paddle.x) / PADDLE_W; // 0..1
        const angle = -Math.PI / 2 + (hitPos - 0.5) * Math.PI * 0.7;
        const speed = Math.hypot(ball.vx, ball.vy);
        ball.vx = Math.cos(angle) * speed;
        ball.vy = Math.sin(angle) * speed;
        ball.y = paddle.y - BALL_R;
      }

      // Brick collisions
      let bricksLeft = 0;
      for (const b of bricks) {
        if (!b.alive) continue;
        bricksLeft++;
        if (rectCircleCollide(b.x, b.y, b.w, b.h, ball.x, ball.y, BALL_R)) {
          resolveCircleRect(b.x, b.y, b.w, b.h, ball);
          b.health--;
          if (b.health <= 0) {
            b.alive = false;
            bricksLeft--;
            score += 10 * b.maxHealth * level;
            updateHUD();
          }
        }
      }

      if (bricksLeft === 0) {
        level++;
        updateHUD();
        bricks = buildBricks(level);
        ball = resetBall();
        ball.x = paddle.x + PADDLE_W / 2;
        state = 'playing';
        showMessage(`Level ${level} — Press SPACE to launch`);
      }
    }

    // ── Draw ──────────────────────────────────────────────────────
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Bricks
      for (const b of bricks) {
        if (!b.alive) continue;
        const alpha = 0.4 + 0.6 * (b.health / b.maxHealth);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.roundRect(b.x, b.y, b.w, b.h, 3);
        ctx.fill();

        // Highlight
        ctx.globalAlpha = alpha * 0.4;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(b.x + 2, b.y + 2, b.w - 4, 3);
        ctx.globalAlpha = 1;

        // Crack marks for damaged multi-hit bricks
        if (b.maxHealth > 1 && b.health < b.maxHealth) {
          ctx.strokeStyle = 'rgba(0,0,0,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(b.x + b.w / 3, b.y + 4);
          ctx.lineTo(b.x + b.w / 2, b.y + b.h - 4);
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1;

      // Paddle
      const grad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + PADDLE_H);
      grad.addColorStop(0, '#7090ff');
      grad.addColorStop(1, '#3050cc');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(paddle.x, paddle.y, PADDLE_W, PADDLE_H, 6);
      ctx.fill();
      ctx.strokeStyle = '#aabbff';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Ball
      const ballGrad = ctx.createRadialGradient(
        ball.x - 2, ball.y - 2, 1,
        ball.x, ball.y, BALL_R
      );
      ballGrad.addColorStop(0, '#ffffff');
      ballGrad.addColorStop(1, '#88aaff');
      ctx.fillStyle = ballGrad;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.fill();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── HUD / message helpers ─────────────────────────────────────
    function updateHUD() {
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('levelDisplay').textContent = level;
      document.getElementById('livesDisplay').textContent = lives;
    }

    function showMessage(msg) {
      document.getElementById('message').textContent = msg;
    }

    function clearMessage() {
      document.getElementById('message').textContent = '';
    }

    function startGame() {
      score = 0;
      lives = 3;
      level = 1;
      paddle.x = W / 2 - PADDLE_W / 2;
      bricks = buildBricks(level);
      ball = resetBall();
      ball.x = paddle.x + PADDLE_W / 2;
      state = 'playing';
      updateHUD();
      showMessage('Press SPACE to launch');
    }

    // ── Input ─────────────────────────────────────────────────────
    document.addEventListener('keydown', e => {
      keys[e.key] = true;

      if (e.key === ' ') {
        e.preventDefault();
        if (state === 'idle' || state === 'dead') {
          startGame();
        } else if (state === 'playing') {
          if (!ball.launched) {
            launchBall();
            clearMessage();
          }
        }
      }
    });

    document.addEventListener('keyup', e => {
      keys[e.key] = false;
    });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
    });

    canvas.addEventListener('mouseleave', () => {
      mouseX = null;
    });

    canvas.addEventListener('click', e => {
      if (state === 'idle' || state === 'dead') {
        startGame();
      } else if (state === 'playing' && !ball.launched) {
        launchBall();
        clearMessage();
      }
    });

    // ── Kick off ──────────────────────────────────────────────────
    updateHUD();
    loop();
  </script>
</body>
</html>
