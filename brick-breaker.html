<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Brick Breaker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0d0d1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #e0e0ff;
      overflow: hidden;
    }

    h1 {
      font-size: clamp(1rem, 5vw, 2rem);
      letter-spacing: 4px;
      margin-bottom: 8px;
      color: #a0aaff;
      text-transform: uppercase;
    }

    #hud {
      display: flex;
      gap: clamp(12px, 4vw, 40px);
      margin-bottom: 8px;
      font-size: clamp(0.7rem, 2.5vw, 1rem);
      letter-spacing: 2px;
    }

    #hud span { color: #7080ff; }
    #hud b    { color: #e0e0ff; }

    canvas {
      display: block;
      background: #0a0a18;
      border: 2px solid #3040a0;
      border-radius: 4px;
      box-shadow: 0 0 30px rgba(80, 100, 255, 0.3);
      /* Scale canvas to fit viewport while keeping aspect ratio */
      width: min(480px, 96vw);
      height: auto;
      touch-action: none;
    }

    #message {
      margin-top: 10px;
      font-size: clamp(0.75rem, 2.5vw, 1.1rem);
      letter-spacing: 2px;
      min-height: 1.5em;
      color: #ffdd88;
      text-align: center;
      padding: 0 8px;
    }

    #controls {
      margin-top: 8px;
      font-size: clamp(0.55rem, 1.8vw, 0.75rem);
      color: #505080;
      letter-spacing: 1px;
      text-align: center;
    }

    #mobileControls {
      display: flex;
      gap: 24px;
      margin-top: 14px;
    }

    #mobileControls button {
      background: #1e2870;
      color: #a0b0ff;
      border: 2px solid #3040a0;
      border-radius: 10px;
      font-size: 1.6rem;
      padding: 14px 32px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      transition: background 0.1s;
    }

    #mobileControls button:active {
      background: #3858cc;
    }

    #btnLaunch {
      background: #2a5cd6;
      color: #ffffff;
      border-color: #6080ff;
      font-size: 1rem;
      letter-spacing: 2px;
      padding: 14px 20px;
      min-width: 90px;
    }

    #btnLaunch:active {
      background: #4a7aff;
    }
  </style>
</head>
<body>
  <h1>Brick Breaker</h1>

  <div id="hud">
    <div><span>SCORE </span><b id="scoreDisplay">0</b></div>
    <div><span>LEVEL </span><b id="levelDisplay">1</b></div>
    <div><span>LIVES </span><b id="livesDisplay">3</b></div>
  </div>

  <canvas id="canvas" width="480" height="560"></canvas>

  <div id="message">Tap or press SPACE to launch</div>
  <div id="controls">Mouse / drag / buttons to move &nbsp;|&nbsp; Tap / SPACE to launch</div>

  <div id="mobileControls">
    <button id="btnLeft">&#9664;</button>
    <button id="btnLaunch">LAUNCH</button>
    <button id="btnRight">&#9654;</button>
  </div>

  <script>
    const canvas  = document.getElementById('canvas');
    const ctx     = canvas.getContext('2d');
    const W = canvas.width;   // logical width  = 480
    const H = canvas.height;  // logical height = 560

    // ── Layout constants ───────────────────────────────────────────
    const PADDLE_W  = 80;
    const PADDLE_H  = 12;
    const PADDLE_Y  = H - 40;
    const PADDLE_SPD = 6;
    const BALL_R    = 7;
    const BASE_SPD  = 6;
    const SPD_MAX   = 15;
    const SPD_BOOST = 1.06;

    const BRICK_COLS = 10;
    const BRICK_ROWS = 6;
    const BRICK_W   = 42;
    const BRICK_H   = 18;
    const BRICK_PAD =  4;
    const BRICK_OX  = (W - (BRICK_COLS * (BRICK_W + BRICK_PAD) - BRICK_PAD)) / 2;
    const BRICK_OY  = 60;

    // ── 4 colours by hit count (1=sky blue, 2=mint, 3=amber, 4=pink) ─
    const BRICK_HUES = [200, 145, 38, 335];   // indexed by maxHp - 1
    function getBrickHue(maxHp)          { return BRICK_HUES[Math.min(maxHp - 1, 3)]; }
    function getBrickColor(maxHp, alpha = 1) {
      return `hsla(${getBrickHue(maxHp)}, 85%, 62%, ${alpha})`;
    }

    // ── State ──────────────────────────────────────────────────────
    let state     = 'idle';
    let score     = 0;
    let lives     = 3;
    let level     = 1;
    let paddle    = { x: W / 2 - PADDLE_W / 2, y: PADDLE_Y };
    let keys      = {};
    let pointerX  = null;   // mouse or touch X in canvas logical coords
    let ball, bricks, particles;

    // ── Ball / brick helpers ───────────────────────────────────────
    function freshBall() {
      return { x: W / 2, y: PADDLE_Y - BALL_R - 1, vx: 0, vy: 0, launched: false };
    }

    function buildBricks(lvl) {
      const maxHP = Math.min(lvl, 4);
      const list  = [];
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          const hp = Math.max(1, Math.min(maxHP, Math.floor(r / 2) + 1));
          list.push({
            x: BRICK_OX + c * (BRICK_W + BRICK_PAD),
            y: BRICK_OY + r * (BRICK_H + BRICK_PAD),
            w: BRICK_W, h: BRICK_H,
            hp, maxHp: hp,
            col: c, row: r,
            alive: true,
          });
        }
      }
      return list;
    }

    function startGame() {
      score = 0; lives = 3; level = 1;
      paddle.x  = W / 2 - PADDLE_W / 2;
      bricks     = buildBricks(1);
      particles  = [];
      ball       = freshBall();
      ball.x     = paddle.x + PADDLE_W / 2;
      state      = 'playing';
      updateHUD();
      showMsg('Tap or press SPACE to launch');
    }

    function launchBall() {
      if (ball.launched) return;
      const spd   = BASE_SPD + (level - 1) * 0.5;
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 3);
      ball.vx = Math.cos(angle) * spd;
      ball.vy = Math.sin(angle) * spd;
      ball.launched = true;
    }

    // Scale ball speed without changing direction
    function nudgeSpeed(factor) {
      const cur = Math.hypot(ball.vx, ball.vy);
      if (cur === 0) return;
      const nxt = Math.min(cur * factor, SPD_MAX);
      ball.vx = (ball.vx / cur) * nxt;
      ball.vy = (ball.vy / cur) * nxt;
    }
    function resetSpeed() {
      const baseSpd = BASE_SPD + (level - 1) * 0.5;
      const cur = Math.hypot(ball.vx, ball.vy);
      if (cur === 0) return;
      ball.vx = (ball.vx / cur) * baseSpd;
      ball.vy = (ball.vy / cur) * baseSpd;
    }

    // ── Particle system ────────────────────────────────────────────
    // Bounce ring: expands outward and fades
    function spawnBounce(x, y, hue) {
      particles.push({
        type: 'ring', x, y,
        r: BALL_R + 1,
        hue: hue ?? 220,
        alpha: 0.9,
      });
    }

    // Brick break: coloured shards fly out and fall
    function spawnBreak(brick) {
      const hue = getBrickHue(brick.maxHp);
      for (let i = 0; i < 16; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd   = 1.5 + Math.random() * 4;
        particles.push({
          type: 'shard',
          x:  brick.x + brick.w / 2 + (Math.random() - 0.5) * brick.w * 0.5,
          y:  brick.y + brick.h / 2 + (Math.random() - 0.5) * brick.h * 0.5,
          vx: Math.cos(angle) * spd,
          vy: Math.sin(angle) * spd - 1,   // slight upward bias
          w:  3 + Math.random() * 5,
          h:  2 + Math.random() * 4,
          rot:  Math.random() * Math.PI * 2,
          rotV: (Math.random() - 0.5) * 0.25,
          hue,
          alpha: 1,
          decay: 0.028 + Math.random() * 0.025,
          gravity: 0.15,
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (p.type === 'ring') {
          p.r    += 2;
          p.alpha -= 0.07;
        } else {
          p.x   += p.vx;
          p.y   += p.vy;
          p.vy  += p.gravity;
          p.rot += p.rotV;
          p.alpha -= p.decay;
        }
        if (p.alpha <= 0) particles.splice(i, 1);
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const a = Math.max(0, p.alpha);
        ctx.save();
        ctx.globalAlpha = a;
        if (p.type === 'ring') {
          ctx.strokeStyle = `hsl(${p.hue}, 90%, 70%)`;
          ctx.lineWidth   = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = `hsl(${p.hue}, 90%, 65%)`;
          ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
        }
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }

    // ── Collision helpers ──────────────────────────────────────────
    function circleRect(cx, cy, cr, rx, ry, rw, rh) {
      const nx = Math.max(rx, Math.min(cx, rx + rw));
      const ny = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - nx, dy = cy - ny;
      return dx * dx + dy * dy < cr * cr;
    }

    function resolveRect(rx, ry, rw, rh, b) {
      const overL = (b.x + BALL_R) - rx;
      const overR = (rx + rw) - (b.x - BALL_R);
      const overT = (b.y + BALL_R) - ry;
      const overB = (ry + rh) - (b.y - BALL_R);
      if (Math.min(overL, overR) < Math.min(overT, overB)) {
        b.vx = -b.vx;
        b.x  = overL < overR ? rx - BALL_R : rx + rw + BALL_R;
      } else {
        b.vy = -b.vy;
        b.y  = overT < overB ? ry - BALL_R : ry + rh + BALL_R;
      }
    }

    // ── Update ─────────────────────────────────────────────────────
    function update() {
      if (state !== 'playing') return;

      // Move paddle
      if (pointerX !== null) paddle.x = pointerX - PADDLE_W / 2;
      if (keys['ArrowLeft'])  paddle.x -= PADDLE_SPD;
      if (keys['ArrowRight']) paddle.x += PADDLE_SPD;
      paddle.x = Math.max(0, Math.min(W - PADDLE_W, paddle.x));

      // Keep ball glued to paddle until launched
      if (!ball.launched) {
        ball.x = paddle.x + PADDLE_W / 2;
        updateParticles();
        return;
      }

      ball.x += ball.vx;
      ball.y += ball.vy;

      // Wall bounces
      if (ball.x - BALL_R < 0) {
        ball.x = BALL_R; ball.vx = Math.abs(ball.vx);
        nudgeSpeed(SPD_BOOST);
        spawnBounce(ball.x, ball.y, 220);
      }
      if (ball.x + BALL_R > W) {
        ball.x = W - BALL_R; ball.vx = -Math.abs(ball.vx);
        nudgeSpeed(SPD_BOOST);
        spawnBounce(ball.x, ball.y, 220);
      }
      if (ball.y - BALL_R < 0) {
        ball.y = BALL_R; ball.vy = Math.abs(ball.vy);
        nudgeSpeed(SPD_BOOST);
        spawnBounce(ball.x, ball.y, 220);
      }

      // Ball fell off bottom – lose life
      if (ball.y - BALL_R > H) {
        lives--;
        updateHUD();
        if (lives <= 0) {
          state = 'dead';
          showMsg('GAME OVER — press LAUNCH to restart');
          updateLaunchBtn();
          return;
        }
        ball   = freshBall();
        ball.x = paddle.x + PADDLE_W / 2;
        showMsg('Press LAUNCH to continue');
        updateLaunchBtn();
        return;
      }

      // Paddle collision
      if (
        ball.vy > 0 &&
        circleRect(ball.x, ball.y, BALL_R, paddle.x, paddle.y, PADDLE_W, PADDLE_H)
      ) {
        const hit   = (ball.x - paddle.x) / PADDLE_W;        // 0 → 1
        const angle = -Math.PI / 2 + (hit - 0.5) * Math.PI * 0.7;
        const baseSpd = BASE_SPD + (level - 1) * 0.5;
        ball.vx = Math.cos(angle) * baseSpd;
        ball.vy = Math.sin(angle) * baseSpd;
        ball.y  = paddle.y - BALL_R;
        spawnBounce(ball.x, ball.y, 200);
      }

      // Brick collisions
      let alive = 0;
      for (const b of bricks) {
        if (!b.alive) continue;
        alive++;
        if (circleRect(ball.x, ball.y, BALL_R, b.x, b.y, b.w, b.h)) {
          resolveRect(b.x, b.y, b.w, b.h, ball);
          nudgeSpeed(SPD_BOOST);
          spawnBounce(ball.x, ball.y, getBrickHue(b.maxHp));
          b.hp--;
          if (b.hp <= 0) {
            b.alive = false;
            alive--;
            spawnBreak(b);
            score += 10 * b.maxHp * level;
            updateHUD();
          }
        }
      }

      // All bricks cleared → next level
      if (alive === 0) {
        level++;
        updateHUD();
        bricks = buildBricks(level);
        ball   = freshBall();
        ball.x = paddle.x + PADDLE_W / 2;
        showMsg(`Level ${level} — press LAUNCH`);
        updateLaunchBtn();
      }

      updateParticles();
    }

    // ── Draw ───────────────────────────────────────────────────────
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Bricks
      for (const b of bricks) {
        if (!b.alive) continue;
        const ratio = b.hp / b.maxHp;
        const alpha = 0.45 + 0.55 * ratio;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle   = getBrickColor(b.maxHp);
        ctx.beginPath();
        ctx.roundRect(b.x, b.y, b.w, b.h, 3);
        ctx.fill();

        // Top-edge shine
        ctx.globalAlpha = alpha * 0.35;
        ctx.fillStyle   = '#ffffff';
        ctx.fillRect(b.x + 2, b.y + 2, b.w - 4, 3);

        // Damage cracks
        if (b.maxHp > 1 && b.hp < b.maxHp) {
          ctx.globalAlpha = 0.6;
          ctx.strokeStyle = 'rgba(0,0,0,0.7)';
          ctx.lineWidth   = 1.5;
          ctx.beginPath();
          ctx.moveTo(b.x + b.w * 0.35, b.y + 3);
          ctx.lineTo(b.x + b.w * 0.50, b.y + b.h - 3);
          ctx.stroke();
          if (b.hp <= b.maxHp - 2) {
            ctx.beginPath();
            ctx.moveTo(b.x + b.w * 0.62, b.y + 3);
            ctx.lineTo(b.x + b.w * 0.47, b.y + b.h - 3);
            ctx.stroke();
          }
        }
        ctx.restore();
      }

      // Particles (behind paddle/ball)
      drawParticles();

      // Paddle
      const pg = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + PADDLE_H);
      pg.addColorStop(0, '#7090ff');
      pg.addColorStop(1, '#3050cc');
      ctx.fillStyle   = pg;
      ctx.strokeStyle = '#aabbff';
      ctx.lineWidth   = 1;
      ctx.beginPath();
      ctx.roundRect(paddle.x, paddle.y, PADDLE_W, PADDLE_H, 6);
      ctx.fill();
      ctx.stroke();

      // Ball
      const bg = ctx.createRadialGradient(
        ball.x - 2, ball.y - 2, 1,
        ball.x,     ball.y,     BALL_R
      );
      bg.addColorStop(0, '#ffffff');
      bg.addColorStop(1, '#88aaff');
      ctx.fillStyle = bg;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.fill();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── HUD helpers ────────────────────────────────────────────────
    function updateHUD() {
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('levelDisplay').textContent = level;
      document.getElementById('livesDisplay').textContent = lives;
    }

    function showMsg(msg) { document.getElementById('message').textContent = msg; }
    function clearMsg()   { document.getElementById('message').textContent = ''; }

    function updateLaunchBtn() {
      const btn = document.getElementById('btnLaunch');
      if (state === 'dead')    { btn.textContent = 'RESTART'; return; }
      if (!ball || !ball.launched) { btn.textContent = 'LAUNCH';  return; }
      btn.textContent = '·····';
    }

    // ── Input ──────────────────────────────────────────────────────
    function handleAction() {
      if (state === 'playing' && !ball.launched) {
        launchBall();
        clearMsg();
      } else if (state === 'idle' || state === 'dead') {
        startGame();
        launchBall();
        clearMsg();
      }
      updateLaunchBtn();
    }

    // Keyboard
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') { e.preventDefault(); handleAction(); }
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // Mouse
    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      pointerX = (e.clientX - r.left) * (W / r.width);
    });
    canvas.addEventListener('mouseleave', () => { pointerX = null; });
    canvas.addEventListener('click', handleAction);

    // Touch – convert from CSS pixels to logical canvas pixels
    function touchX(e) {
      const r = canvas.getBoundingClientRect();
      return (e.touches[0].clientX - r.left) * (W / r.width);
    }

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      pointerX = touchX(e);
      handleAction();
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      pointerX = touchX(e);
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
      e.preventDefault();
    }, { passive: false });

    // Mobile left/right buttons
    const btnLeft  = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    function holdLeft(down)  { keys['ArrowLeft']  = down; }
    function holdRight(down) { keys['ArrowRight'] = down; }

    btnLeft.addEventListener('pointerdown',  e => { e.preventDefault(); holdLeft(true);  handleAction(); });
    btnLeft.addEventListener('pointerup',    e => { e.preventDefault(); holdLeft(false); });
    btnLeft.addEventListener('pointerleave', e => { holdLeft(false); });

    btnRight.addEventListener('pointerdown',  e => { e.preventDefault(); holdRight(true);  handleAction(); });
    btnRight.addEventListener('pointerup',    e => { e.preventDefault(); holdRight(false); });
    btnRight.addEventListener('pointerleave', e => { holdRight(false); });

    const btnLaunch = document.getElementById('btnLaunch');
    btnLaunch.addEventListener('pointerdown', e => { e.preventDefault(); handleAction(); });

    // ── Boot ───────────────────────────────────────────────────────
    startGame();
    updateLaunchBtn();
    loop();
  </script>
</body>
</html>
